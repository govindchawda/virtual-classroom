import {
  require_react
} from "./chunk-GUKOQ7ZL.js";
import {
  __commonJS,
  __require
} from "./chunk-PR4QN5HX.js";

// node_modules/validatorjs/src/rules.js
var require_rules = __commonJS({
  "node_modules/validatorjs/src/rules.js"(exports, module) {
    function leapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function checkFalsePositiveDates(dateString = "") {
      if (dateString.length === 10) {
        let normalizedDate = dateString.replace(".", "-").replace("/", "-");
        let parts = normalizedDate.split("-");
        if (parts.length === 3) {
          if (parts[0].length === 4) {
            let y = parseInt(parts[0]);
            let m = parseInt(parts[1]);
            let d = parseInt(parts[2]);
            if (m === 2) {
              if (leapYear(y)) {
                if (d > 29) {
                  return false;
                }
              } else {
                if (d > 28) {
                  return false;
                }
              }
            }
            if (m === 4 || m === 6 || m === 9 || m === 11) {
              if (d > 30) {
                return false;
              }
            }
          }
        }
        return true;
      }
      return true;
    }
    function isValidDate(dateString) {
      let testDate;
      if (typeof dateString === "number") {
        testDate = new Date(dateString);
        if (typeof testDate === "object") {
          return true;
        }
      }
      testDate = new Date(dateString);
      if (typeof testDate === "object") {
        if (testDate.toString() === "Invalid Date") {
          return false;
        }
        if (!checkFalsePositiveDates(dateString)) {
          return false;
        }
        return true;
      }
      var regex_date = /^\d{4}\-\d{1,2}\-\d{1,2}$/;
      if (!regex_date.test(dateString)) {
        return false;
      }
      var parts = dateString.split("-");
      var day = parseInt(parts[2], 10);
      var month = parseInt(parts[1], 10);
      var year = parseInt(parts[0], 10);
      if (year < 1e3 || year > 3e3 || month == 0 || month > 12) {
        return false;
      }
      var monthLength = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      if (year % 400 == 0 || year % 100 != 0 && year % 4 == 0) {
        monthLength[1] = 29;
      }
      return day > 0 && day <= monthLength[month - 1];
    }
    var rules = {
      required: function(val) {
        var str;
        if (val === void 0 || val === null) {
          return false;
        }
        str = String(val).replace(/\s/g, "");
        return str.length > 0 ? true : false;
      },
      required_if: function(val, req, attribute) {
        req = this.getParameters();
        if (this.validator._objectPath(this.validator.input, req[0]) === req[1]) {
          return this.validator.getRule("required").validate(val);
        }
        return true;
      },
      required_unless: function(val, req, attribute) {
        req = this.getParameters();
        if (this.validator._objectPath(this.validator.input, req[0]) !== req[1]) {
          return this.validator.getRule("required").validate(val);
        }
        return true;
      },
      required_with: function(val, req, attribute) {
        if (this.validator._objectPath(this.validator.input, req)) {
          return this.validator.getRule("required").validate(val);
        }
        return true;
      },
      required_with_all: function(val, req, attribute) {
        req = this.getParameters();
        for (var i = 0; i < req.length; i++) {
          if (!this.validator._objectPath(this.validator.input, req[i])) {
            return true;
          }
        }
        return this.validator.getRule("required").validate(val);
      },
      required_without: function(val, req, attribute) {
        if (this.validator._objectPath(this.validator.input, req)) {
          return true;
        }
        return this.validator.getRule("required").validate(val);
      },
      required_without_all: function(val, req, attribute) {
        req = this.getParameters();
        for (var i = 0; i < req.length; i++) {
          if (this.validator._objectPath(this.validator.input, req[i])) {
            return true;
          }
        }
        return this.validator.getRule("required").validate(val);
      },
      boolean: function(val) {
        return val === true || val === false || val === 0 || val === 1 || val === "0" || val === "1" || val === "true" || val === "false";
      },
      // compares the size of strings
      // with numbers, compares the value
      size: function(val, req, attribute) {
        if (val) {
          req = parseFloat(req);
          var size = this.getSize();
          return size === req;
        }
        return true;
      },
      string: function(val, req, attribute) {
        return typeof val === "string";
      },
      sometimes: function(val) {
        return true;
      },
      /**
       * Compares the size of strings or the value of numbers if there is a truthy value
       */
      min: function(val, req, attribute) {
        var size = this.getSize();
        return size >= req;
      },
      /**
       * Compares the size of strings or the value of numbers if there is a truthy value
       */
      max: function(val, req, attribute) {
        var size = this.getSize();
        return size <= req;
      },
      between: function(val, req, attribute) {
        req = this.getParameters();
        var size = this.getSize();
        var min = parseFloat(req[0], 10);
        var max = parseFloat(req[1], 10);
        return size >= min && size <= max;
      },
      email: function(val) {
        var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        if (!re.test(val)) {
          re = /^((?:[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]|[^\u0000-\u007F])+@(?:[a-zA-Z0-9]|[^\u0000-\u007F])(?:(?:[a-zA-Z0-9-]|[^\u0000-\u007F]){0,61}(?:[a-zA-Z0-9]|[^\u0000-\u007F]))?(?:\.(?:[a-zA-Z0-9]|[^\u0000-\u007F])(?:(?:[a-zA-Z0-9-]|[^\u0000-\u007F]){0,61}(?:[a-zA-Z0-9]|[^\u0000-\u007F]))?)+)*$/;
        }
        return re.test(val);
      },
      numeric: function(val) {
        var num;
        num = Number(val);
        if (typeof num === "number" && !isNaN(num) && typeof val !== "boolean") {
          return true;
        } else {
          return false;
        }
      },
      array: function(val) {
        return val instanceof Array;
      },
      url: function(url) {
        return /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_\+.~#?&/=]*)/i.test(url);
      },
      alpha: function(val) {
        return /^[a-zA-Z]+$/.test(val);
      },
      alpha_dash: function(val) {
        return /^[a-zA-Z0-9_\-]+$/.test(val);
      },
      alpha_num: function(val) {
        return /^[a-zA-Z0-9]+$/.test(val);
      },
      same: function(val, req) {
        var val1 = this.validator._flattenObject(this.validator.input)[req];
        var val2 = val;
        if (val1 === val2) {
          return true;
        }
        return false;
      },
      different: function(val, req) {
        var val1 = this.validator._flattenObject(this.validator.input)[req];
        var val2 = val;
        if (val1 !== val2) {
          return true;
        }
        return false;
      },
      in: function(val, req) {
        var list, i;
        if (val) {
          list = this.getParameters();
        }
        if (val && !(val instanceof Array)) {
          var localValue = val;
          for (i = 0; i < list.length; i++) {
            if (typeof list[i] === "string") {
              localValue = String(val);
            }
            if (localValue === list[i]) {
              return true;
            }
          }
          return false;
        }
        if (val && val instanceof Array) {
          for (i = 0; i < val.length; i++) {
            if (list.indexOf(val[i]) < 0) {
              return false;
            }
          }
        }
        return true;
      },
      not_in: function(val, req) {
        var list = this.getParameters();
        var len = list.length;
        var returnVal = true;
        for (var i = 0; i < len; i++) {
          var localValue = val;
          if (typeof list[i] === "string") {
            localValue = String(val);
          }
          if (localValue === list[i]) {
            returnVal = false;
            break;
          }
        }
        return returnVal;
      },
      accepted: function(val) {
        if (val === "on" || val === "yes" || val === 1 || val === "1" || val === true) {
          return true;
        }
        return false;
      },
      confirmed: function(val, req, key) {
        var confirmedKey = key + "_confirmation";
        if (this.validator.input[confirmedKey] === val) {
          return true;
        }
        return false;
      },
      integer: function(val) {
        return String(parseInt(val, 10)) === String(val);
      },
      digits: function(val, req) {
        var numericRule = this.validator.getRule("numeric");
        if (numericRule.validate(val) && String(val.trim()).length === parseInt(req)) {
          return true;
        }
        return false;
      },
      digits_between: function(val) {
        var numericRule = this.validator.getRule("numeric");
        var req = this.getParameters();
        var valueDigitsCount = String(val).length;
        var min = parseFloat(req[0], 10);
        var max = parseFloat(req[1], 10);
        if (numericRule.validate(val) && valueDigitsCount >= min && valueDigitsCount <= max) {
          return true;
        }
        return false;
      },
      regex: function(val, req) {
        let reqPattern = req;
        var mod = /[g|i|m]{1,3}$/;
        var flag = req.match(mod);
        flag = flag ? flag[0] : "";
        req = req.replace(mod, "").slice(1, -1);
        req = new RegExp(req, flag);
        return !!req.test(val);
      },
      date: function(val, format) {
        return isValidDate(val);
      },
      present: function(val) {
        return typeof val !== "undefined";
      },
      after: function(val, req) {
        var val1 = this.validator.input[req];
        var val2 = val;
        if (!isValidDate(val1)) {
          return false;
        }
        if (!isValidDate(val2)) {
          return false;
        }
        if (new Date(val1).getTime() < new Date(val2).getTime()) {
          return true;
        }
        return false;
      },
      after_or_equal: function(val, req) {
        var val1 = this.validator.input[req];
        var val2 = val;
        if (!isValidDate(val1)) {
          return false;
        }
        if (!isValidDate(val2)) {
          return false;
        }
        if (new Date(val1).getTime() <= new Date(val2).getTime()) {
          return true;
        }
        return false;
      },
      before: function(val, req) {
        var val1 = this.validator.input[req];
        var val2 = val;
        if (!isValidDate(val1)) {
          return false;
        }
        if (!isValidDate(val2)) {
          return false;
        }
        if (new Date(val1).getTime() > new Date(val2).getTime()) {
          return true;
        }
        return false;
      },
      before_or_equal: function(val, req) {
        var val1 = this.validator.input[req];
        var val2 = val;
        if (!isValidDate(val1)) {
          return false;
        }
        if (!isValidDate(val2)) {
          return false;
        }
        if (new Date(val1).getTime() >= new Date(val2).getTime()) {
          return true;
        }
        return false;
      },
      hex: function(val) {
        return /^[0-9a-f]+$/i.test(val);
      },
      ipv4: function(val, req, attribute) {
        if (typeof val != "string")
          return false;
        var er = /^[0-9]+$/;
        octets = val.split(".");
        if (octets.length != 4)
          return false;
        for (let i = 0; i < octets.length; i++) {
          const element = octets[i];
          if (!er.test(element))
            return false;
          var octetValue = parseInt(element);
          if (octetValue >= 256)
            return false;
        }
        return true;
      },
      ipv6: function(val, req, attribute) {
        if (typeof val != "string")
          return false;
        var er = /^[0-9a-f]+$/;
        hextets = val.split(":");
        colons = val.match(/::/);
        if (colons != null && val.match(/::/g).length > 1)
          return false;
        if (val[0] == ":" && (colons == null || colons != null && colons.index != 0))
          return false;
        if (val[val.length - 1] == ":" && (colons == null || colons != null && colons.index != val.length - 2))
          return false;
        if (3 > hextets.length)
          return false;
        var isEdgeCase = hextets.length == 9 && colons != null && (colons.index == 0 || colons.index == val.length - 2);
        if (hextets.length > 8 && !isEdgeCase)
          return false;
        if (hextets.length != 8 && colons == null)
          return false;
        for (let i = 0; i < hextets.length; i++) {
          const element = hextets[i];
          if (element.length == 0)
            continue;
          if (!er.test(element))
            return false;
          if (element.length > 4)
            return false;
        }
        return true;
      },
      ip: function(val, req, attribute) {
        return rules["ipv4"](val, req, attribute) || rules["ipv6"](val, req, attribute);
      }
    };
    var missedRuleValidator = function() {
      throw new Error("Validator `" + this.name + "` is not defined!");
    };
    var missedRuleMessage;
    function Rule(name, fn, async) {
      this.name = name;
      this.fn = fn;
      this.passes = null;
      this._customMessage = void 0;
      this.async = async;
    }
    Rule.prototype = {
      /**
       * Validate rule
       *
       * @param  {mixed} inputValue
       * @param  {mixed} ruleValue
       * @param  {string} attribute
       * @param  {function} callback
       * @return {boolean|undefined}
       */
      validate: function(inputValue, ruleValue, attribute, callback) {
        var _this = this;
        this._setValidatingData(attribute, inputValue, ruleValue);
        if (typeof callback === "function") {
          this.callback = callback;
          var handleResponse = function(passes, message) {
            _this.response(passes, message);
          };
          if (this.async) {
            return this._apply(inputValue, ruleValue, attribute, handleResponse);
          } else {
            return handleResponse(this._apply(inputValue, ruleValue, attribute));
          }
        }
        return this._apply(inputValue, ruleValue, attribute);
      },
      /**
       * Apply validation function
       *
       * @param  {mixed} inputValue
       * @param  {mixed} ruleValue
       * @param  {string} attribute
       * @param  {function} callback
       * @return {boolean|undefined}
       */
      _apply: function(inputValue, ruleValue, attribute, callback) {
        var fn = this.isMissed() ? missedRuleValidator : this.fn;
        return fn.apply(this, [inputValue, ruleValue, attribute, callback]);
      },
      /**
       * Set validating data
       *
       * @param {string} attribute
       * @param {mixed} inputValue
       * @param {mixed} ruleValue
       * @return {void}
       */
      _setValidatingData: function(attribute, inputValue, ruleValue) {
        this.attribute = attribute;
        this.inputValue = inputValue;
        this.ruleValue = ruleValue;
      },
      /**
       * Get parameters
       *
       * @return {array}
       */
      getParameters: function() {
        var value = [];
        if (typeof this.ruleValue === "string") {
          value = this.ruleValue.split(",");
        }
        if (typeof this.ruleValue === "number") {
          value.push(this.ruleValue);
        }
        if (this.ruleValue instanceof Array) {
          value = this.ruleValue;
        }
        return value;
      },
      /**
       * Get true size of value
       *
       * @return {integer|float}
       */
      getSize: function() {
        var value = this.inputValue;
        if (value instanceof Array) {
          return value.length;
        }
        if (typeof value === "number") {
          return value;
        }
        if (this.validator._hasNumericRule(this.attribute)) {
          return parseFloat(value, 10);
        }
        return value.length;
      },
      /**
       * Get the type of value being checked; numeric or string.
       *
       * @return {string}
       */
      _getValueType: function() {
        if (typeof this.inputValue === "number" || this.validator._hasNumericRule(this.attribute)) {
          return "numeric";
        }
        return "string";
      },
      /**
       * Set the async callback response
       *
       * @param  {boolean|undefined} passes  Whether validation passed
       * @param  {string|undefined} message Custom error message
       * @return {void}
       */
      response: function(passes, message) {
        this.passes = passes === void 0 || passes === true;
        this._customMessage = message;
        this.callback(this.passes, message);
      },
      /**
       * Set validator instance
       *
       * @param {Validator} validator
       * @return {void}
       */
      setValidator: function(validator) {
        this.validator = validator;
      },
      /**
       * Check if rule is missed
       *
       * @return {boolean}
       */
      isMissed: function() {
        return typeof this.fn !== "function";
      },
      get customMessage() {
        return this.isMissed() ? missedRuleMessage : this._customMessage;
      }
    };
    var manager = {
      /**
       * List of async rule names
       *
       * @type {Array}
       */
      asyncRules: [],
      /**
       * Implicit rules (rules to always validate)
       *
       * @type {Array}
       */
      implicitRules: [
        "required",
        "required_if",
        "required_unless",
        "required_with",
        "required_with_all",
        "required_without",
        "required_without_all",
        "accepted",
        "present"
      ],
      /**
       * Get rule by name
       *
       * @param  {string} name
       * @param {Validator}
       * @return {Rule}
       */
      make: function(name, validator) {
        var async = this.isAsync(name);
        var rule = new Rule(name, rules[name], async);
        rule.setValidator(validator);
        return rule;
      },
      /**
       * Determine if given rule is async
       *
       * @param  {string}  name
       * @return {boolean}
       */
      isAsync: function(name) {
        for (var i = 0, len = this.asyncRules.length; i < len; i++) {
          if (this.asyncRules[i] === name) {
            return true;
          }
        }
        return false;
      },
      /**
       * Determine if rule is implicit (should always validate)
       *
       * @param {string} name
       * @return {boolean}
       */
      isImplicit: function(name) {
        return this.implicitRules.indexOf(name) > -1;
      },
      /**
       * Register new rule
       *
       * @param  {string}   name
       * @param  {function} fn
       * @return {void}
       */
      register: function(name, fn) {
        rules[name] = fn;
      },
      /**
       * Register new implicit rule
       *
       * @param  {string}   name
       * @param  {function} fn
       * @return {void}
       */
      registerImplicit: function(name, fn) {
        this.register(name, fn);
        this.implicitRules.push(name);
      },
      /**
       * Register async rule
       *
       * @param  {string}   name
       * @param  {function} fn
       * @return {void}
       */
      registerAsync: function(name, fn) {
        this.register(name, fn);
        this.asyncRules.push(name);
      },
      /**
       * Register implicit async rule
       *
       * @param  {string}   name
       * @param  {function} fn
       * @return {void}
       */
      registerAsyncImplicit: function(name, fn) {
        this.registerImplicit(name, fn);
        this.asyncRules.push(name);
      },
      registerMissedRuleValidator: function(fn, message) {
        missedRuleValidator = fn;
        missedRuleMessage = message;
      }
    };
    module.exports = manager;
  }
});

// node_modules/validatorjs/src/attributes.js
var require_attributes = __commonJS({
  "node_modules/validatorjs/src/attributes.js"(exports, module) {
    var replacements = {
      /**
       * Between replacement (replaces :min and :max)
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      between: function(template, rule) {
        var parameters = rule.getParameters();
        return this._replacePlaceholders(rule, template, {
          min: parameters[0],
          max: parameters[1]
        });
      },
      /**
       * Digits-Between replacement (replaces :min and :max)
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      digits_between: function(template, rule) {
        var parameters = rule.getParameters();
        return this._replacePlaceholders(rule, template, {
          min: parameters[0],
          max: parameters[1]
        });
      },
      /**
       * Required_if replacement.
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      required_if: function(template, rule) {
        var parameters = rule.getParameters();
        return this._replacePlaceholders(rule, template, {
          other: this._getAttributeName(parameters[0]),
          value: parameters[1]
        });
      },
      /**
       * Required_unless replacement.
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      required_unless: function(template, rule) {
        var parameters = rule.getParameters();
        return this._replacePlaceholders(rule, template, {
          other: this._getAttributeName(parameters[0]),
          value: parameters[1]
        });
      },
      /**
       * Required_with replacement.
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      required_with: function(template, rule) {
        var parameters = rule.getParameters();
        return this._replacePlaceholders(rule, template, {
          field: this._getAttributeName(parameters[0])
        });
      },
      /**
       * Required_with_all replacement.
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      required_with_all: function(template, rule) {
        var parameters = rule.getParameters();
        var getAttributeName = this._getAttributeName.bind(this);
        return this._replacePlaceholders(rule, template, {
          fields: parameters.map(getAttributeName).join(", ")
        });
      },
      /**
       * Required_without replacement.
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      required_without: function(template, rule) {
        var parameters = rule.getParameters();
        return this._replacePlaceholders(rule, template, {
          field: this._getAttributeName(parameters[0])
        });
      },
      /**
       * Required_without_all replacement.
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      required_without_all: function(template, rule) {
        var parameters = rule.getParameters();
        var getAttributeName = this._getAttributeName.bind(this);
        return this._replacePlaceholders(rule, template, {
          fields: parameters.map(getAttributeName).join(", ")
        });
      },
      /**
       * After replacement.
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      after: function(template, rule) {
        var parameters = rule.getParameters();
        return this._replacePlaceholders(rule, template, {
          after: this._getAttributeName(parameters[0])
        });
      },
      /**
       * Before replacement.
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      before: function(template, rule) {
        var parameters = rule.getParameters();
        return this._replacePlaceholders(rule, template, {
          before: this._getAttributeName(parameters[0])
        });
      },
      /**
       * After_or_equal replacement.
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      after_or_equal: function(template, rule) {
        var parameters = rule.getParameters();
        return this._replacePlaceholders(rule, template, {
          after_or_equal: this._getAttributeName(parameters[0])
        });
      },
      /**
       * Before_or_equal replacement.
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      before_or_equal: function(template, rule) {
        var parameters = rule.getParameters();
        return this._replacePlaceholders(rule, template, {
          before_or_equal: this._getAttributeName(parameters[0])
        });
      },
      /**
       * Same replacement.
       *
       * @param  {string} template
       * @param  {Rule} rule
       * @return {string}
       */
      same: function(template, rule) {
        var parameters = rule.getParameters();
        return this._replacePlaceholders(rule, template, {
          same: this._getAttributeName(parameters[0])
        });
      }
    };
    function formatter(attribute) {
      return attribute.replace(/[_\[]/g, " ").replace(/]/g, "");
    }
    module.exports = {
      replacements,
      formatter
    };
  }
});

// node_modules/validatorjs/src/messages.js
var require_messages = __commonJS({
  "node_modules/validatorjs/src/messages.js"(exports, module) {
    var Attributes = require_attributes();
    var Messages = function(lang, messages) {
      this.lang = lang;
      this.messages = messages;
      this.customMessages = {};
      this.attributeNames = {};
    };
    Messages.prototype = {
      constructor: Messages,
      /**
       * Set custom messages
       *
       * @param {object} customMessages
       * @return {void}
       */
      _setCustom: function(customMessages) {
        this.customMessages = customMessages || {};
      },
      /**
       * Set custom attribute names.
       *
       * @param {object} attributes
       */
      _setAttributeNames: function(attributes) {
        this.attributeNames = attributes;
      },
      /**
       * Set the attribute formatter.
       *
       * @param {fuction} func
       * @return {void}
       */
      _setAttributeFormatter: function(func) {
        this.attributeFormatter = func;
      },
      /**
       * Get attribute name to display.
       *
       * @param  {string} attribute
       * @return {string}
       */
      _getAttributeName: function(attribute) {
        var name = attribute;
        if (this.attributeNames.hasOwnProperty(attribute)) {
          return this.attributeNames[attribute];
        } else if (this.messages.attributes.hasOwnProperty(attribute)) {
          name = this.messages.attributes[attribute];
        }
        if (this.attributeFormatter) {
          name = this.attributeFormatter(name);
        }
        return name;
      },
      /**
       * Get all messages
       *
       * @return {object}
       */
      all: function() {
        return this.messages;
      },
      /**
       * Render message
       *
       * @param  {Rule} rule
       * @return {string}
       */
      render: function(rule) {
        if (rule.customMessage) {
          return rule.customMessage;
        }
        var template = this._getTemplate(rule);
        var message;
        if (Attributes.replacements[rule.name]) {
          message = Attributes.replacements[rule.name].apply(this, [template, rule]);
        } else {
          message = this._replacePlaceholders(rule, template, {});
        }
        return message;
      },
      /**
       * Get the template to use for given rule
       *
       * @param  {Rule} rule
       * @return {string}
       */
      _getTemplate: function(rule) {
        var messages = this.messages;
        var template = messages.def;
        var customMessages = this.customMessages;
        var formats = [rule.name + "." + rule.attribute, rule.name];
        for (var i = 0, format; i < formats.length; i++) {
          format = formats[i];
          if (customMessages.hasOwnProperty(format)) {
            template = customMessages[format];
            break;
          } else if (messages.hasOwnProperty(format)) {
            template = messages[format];
            break;
          }
        }
        if (typeof template === "object") {
          template = template[rule._getValueType()];
        }
        return template;
      },
      /**
       * Replace placeholders in the template using the data object
       *
       * @param  {Rule} rule
       * @param  {string} template
       * @param  {object} data
       * @return {string}
       */
      _replacePlaceholders: function(rule, template, data) {
        var message, attribute;
        data.attribute = this._getAttributeName(rule.attribute);
        data[rule.name] = data[rule.name] || rule.getParameters().join(",");
        if (typeof template === "string" && typeof data === "object") {
          message = template;
          for (attribute in data) {
            message = message.replace(new RegExp(":" + attribute, "g"), data[attribute]);
          }
        }
        return message;
      }
    };
    module.exports = Messages;
  }
});

// node_modules/validatorjs/src/lang/en.js
var require_en = __commonJS({
  "node_modules/validatorjs/src/lang/en.js"(exports, module) {
    module.exports = {
      accepted: "The :attribute must be accepted.",
      after: "The :attribute must be after :after.",
      after_or_equal: "The :attribute must be equal or after :after_or_equal.",
      alpha: "The :attribute field must contain only alphabetic characters.",
      alpha_dash: "The :attribute field may only contain alpha-numeric characters, as well as dashes and underscores.",
      alpha_num: "The :attribute field must be alphanumeric.",
      before: "The :attribute must be before :before.",
      before_or_equal: "The :attribute must be equal or before :before_or_equal.",
      between: {
        numeric: "The :attribute field must be between :min and :max.",
        string: "The :attribute field must be between :min and :max characters."
      },
      confirmed: "The :attribute confirmation does not match.",
      email: "The :attribute format is invalid.",
      date: "The :attribute is not a valid date format.",
      def: "The :attribute attribute has errors.",
      digits: "The :attribute must be :digits digits.",
      digits_between: "The :attribute field must be between :min and :max digits.",
      different: "The :attribute and :different must be different.",
      in: "The selected :attribute is invalid.",
      integer: "The :attribute must be an integer.",
      hex: "The :attribute field should have hexadecimal format",
      min: {
        numeric: "The :attribute must be at least :min.",
        string: "The :attribute must be at least :min characters."
      },
      max: {
        numeric: "The :attribute may not be greater than :max.",
        string: "The :attribute may not be greater than :max characters."
      },
      not_in: "The selected :attribute is invalid.",
      numeric: "The :attribute must be a number.",
      present: "The :attribute field must be present (but can be empty).",
      required: "The :attribute field is required.",
      required_if: "The :attribute field is required when :other is :value.",
      required_unless: "The :attribute field is required when :other is not :value.",
      required_with: "The :attribute field is required when :field is not empty.",
      required_with_all: "The :attribute field is required when :fields are not empty.",
      required_without: "The :attribute field is required when :field is empty.",
      required_without_all: "The :attribute field is required when :fields are empty.",
      same: "The :attribute and :same fields must match.",
      size: {
        numeric: "The :attribute must be :size.",
        string: "The :attribute must be :size characters."
      },
      string: "The :attribute must be a string.",
      url: "The :attribute format is invalid.",
      regex: "The :attribute format is invalid.",
      attributes: {}
    };
  }
});

// node_modules/validatorjs/src/lang.js
var require_lang = __commonJS({
  "node_modules/validatorjs/src/lang.js"(exports, module) {
    var Messages = require_messages();
    require_en();
    var require_method = __require;
    var container = {
      messages: {},
      /**
       * Set messages for language
       *
       * @param {string} lang
       * @param {object} rawMessages
       * @return {void}
       */
      _set: function(lang, rawMessages) {
        this.messages[lang] = rawMessages;
      },
      /**
       * Set message for given language's rule.
       *
       * @param {string} lang
       * @param {string} attribute
       * @param {string|object} message
       * @return {void}
       */
      _setRuleMessage: function(lang, attribute, message) {
        this._load(lang);
        if (message === void 0) {
          message = this.messages[lang].def;
        }
        this.messages[lang][attribute] = message;
      },
      /**
       * Load messages (if not already loaded)
       *
       * @param  {string} lang
       * @return {void}
       */
      _load: function(lang) {
        if (!this.messages[lang]) {
          try {
            var rawMessages = require_method("./lang/" + lang);
            this._set(lang, rawMessages);
          } catch (e) {
          }
        }
      },
      /**
       * Get raw messages for language
       *
       * @param  {string} lang
       * @return {object}
       */
      _get: function(lang) {
        this._load(lang);
        return this.messages[lang];
      },
      /**
       * Make messages for given language
       *
       * @param  {string} lang
       * @return {Messages}
       */
      _make: function(lang) {
        this._load(lang);
        return new Messages(lang, this.messages[lang]);
      }
    };
    module.exports = container;
  }
});

// node_modules/validatorjs/src/errors.js
var require_errors = __commonJS({
  "node_modules/validatorjs/src/errors.js"(exports, module) {
    var Errors = function() {
      this.errors = {};
    };
    Errors.prototype = {
      constructor: Errors,
      /**
       * Add new error message for given attribute
       *
       * @param  {string} attribute
       * @param  {string} message
       * @return {void}
       */
      add: function(attribute, message) {
        if (!this.has(attribute)) {
          this.errors[attribute] = [];
        }
        if (this.errors[attribute].indexOf(message) === -1) {
          this.errors[attribute].push(message);
        }
      },
      /**
       * Returns an array of error messages for an attribute, or an empty array
       *
       * @param  {string} attribute A key in the data object being validated
       * @return {array} An array of error messages
       */
      get: function(attribute) {
        if (this.has(attribute)) {
          return this.errors[attribute];
        }
        return [];
      },
      /**
       * Returns the first error message for an attribute, false otherwise
       *
       * @param  {string} attribute A key in the data object being validated
       * @return {string|false} First error message or false
       */
      first: function(attribute) {
        if (this.has(attribute)) {
          return this.errors[attribute][0];
        }
        return false;
      },
      /**
       * Get all error messages from all failing attributes
       *
       * @return {Object} Failed attribute names for keys and an array of messages for values
       */
      all: function() {
        return this.errors;
      },
      /**
       * Determine if there are any error messages for an attribute
       *
       * @param  {string}  attribute A key in the data object being validated
       * @return {boolean}
       */
      has: function(attribute) {
        if (this.errors.hasOwnProperty(attribute)) {
          return true;
        }
        return false;
      }
    };
    module.exports = Errors;
  }
});

// node_modules/validatorjs/src/async.js
var require_async = __commonJS({
  "node_modules/validatorjs/src/async.js"(exports, module) {
    function AsyncResolvers(onFailedOne, onResolvedAll) {
      this.onResolvedAll = onResolvedAll;
      this.onFailedOne = onFailedOne;
      this.resolvers = {};
      this.resolversCount = 0;
      this.passed = [];
      this.failed = [];
      this.firing = false;
    }
    AsyncResolvers.prototype = {
      /**
       * Add resolver
       *
       * @param {Rule} rule
       * @return {integer}
       */
      add: function(rule) {
        var index = this.resolversCount;
        this.resolvers[index] = rule;
        this.resolversCount++;
        return index;
      },
      /**
       * Resolve given index
       *
       * @param  {integer} index
       * @return {void}
       */
      resolve: function(index) {
        var rule = this.resolvers[index];
        if (rule.passes === true) {
          this.passed.push(rule);
        } else if (rule.passes === false) {
          this.failed.push(rule);
          this.onFailedOne(rule);
        }
        this.fire();
      },
      /**
       * Determine if all have been resolved
       *
       * @return {boolean}
       */
      isAllResolved: function() {
        return this.passed.length + this.failed.length === this.resolversCount;
      },
      /**
       * Attempt to fire final all resolved callback if completed
       *
       * @return {void}
       */
      fire: function() {
        if (!this.firing) {
          return;
        }
        if (this.isAllResolved()) {
          this.onResolvedAll(this.failed.length === 0);
        }
      },
      /**
       * Enable firing
       *
       * @return {void}
       */
      enableFiring: function() {
        this.firing = true;
      }
    };
    module.exports = AsyncResolvers;
  }
});

// node_modules/validatorjs/src/validator.js
var require_validator = __commonJS({
  "node_modules/validatorjs/src/validator.js"(exports, module) {
    var Rules = require_rules();
    var Lang = require_lang();
    var Errors = require_errors();
    var Attributes = require_attributes();
    var AsyncResolvers = require_async();
    var Validator = function(input, rules, customMessages) {
      var lang = Validator.getDefaultLang();
      this.input = input || {};
      this.messages = Lang._make(lang);
      this.messages._setCustom(customMessages);
      this.setAttributeFormatter(Validator.prototype.attributeFormatter);
      this.errors = new Errors();
      this.errorCount = 0;
      this.hasAsync = false;
      this.rules = this._parseRules(rules);
    };
    Validator.prototype = {
      constructor: Validator,
      /**
       * Default language
       *
       * @type {string}
       */
      lang: "en",
      /**
       * Numeric based rules
       *
       * @type {array}
       */
      numericRules: ["integer", "numeric"],
      /**
       * Attribute formatter.
       *
       * @type {function}
       */
      attributeFormatter: Attributes.formatter,
      /**
       * Run validator
       *
       * @return {boolean} Whether it passes; true = passes, false = fails
       */
      check: function() {
        var self = this;
        for (var attribute in this.rules) {
          var attributeRules = this.rules[attribute];
          var inputValue = this._objectPath(this.input, attribute);
          if (this._hasRule(attribute, ["sometimes"]) && !this._suppliedWithData(attribute)) {
            continue;
          }
          for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {
            ruleOptions = attributeRules[i];
            rule = this.getRule(ruleOptions.name);
            if (!this._isValidatable(rule, inputValue)) {
              continue;
            }
            rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);
            if (!rulePassed) {
              this._addFailure(rule);
            }
            if (this._shouldStopValidating(attribute, rulePassed)) {
              break;
            }
          }
        }
        return this.errorCount === 0;
      },
      /**
       * Run async validator
       *
       * @param {function} passes
       * @param {function} fails
       * @return {void}
       */
      checkAsync: function(passes, fails) {
        var _this = this;
        passes = passes || function() {
        };
        fails = fails || function() {
        };
        var failsOne = function(rule2, message) {
          _this._addFailure(rule2, message);
        };
        var resolvedAll = function(allPassed) {
          if (allPassed) {
            passes();
          } else {
            fails();
          }
        };
        var asyncResolvers = new AsyncResolvers(failsOne, resolvedAll);
        var validateRule = function(inputValue2, ruleOptions2, attribute2, rule2) {
          return function() {
            var resolverIndex = asyncResolvers.add(rule2);
            rule2.validate(inputValue2, ruleOptions2.value, attribute2, function() {
              asyncResolvers.resolve(resolverIndex);
            });
          };
        };
        for (var attribute in this.rules) {
          var attributeRules = this.rules[attribute];
          var inputValue = this._objectPath(this.input, attribute);
          if (this._hasRule(attribute, ["sometimes"]) && !this._suppliedWithData(attribute)) {
            continue;
          }
          for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {
            ruleOptions = attributeRules[i];
            rule = this.getRule(ruleOptions.name);
            if (!this._isValidatable(rule, inputValue)) {
              continue;
            }
            validateRule(inputValue, ruleOptions, attribute, rule)();
          }
        }
        asyncResolvers.enableFiring();
        asyncResolvers.fire();
      },
      /**
       * Add failure and error message for given rule
       *
       * @param {Rule} rule
       */
      _addFailure: function(rule) {
        var msg = this.messages.render(rule);
        this.errors.add(rule.attribute, msg);
        this.errorCount++;
      },
      /**
       * Flatten nested object, normalizing { foo: { bar: 1 } } into: { 'foo.bar': 1 }
       *
       * @param  {object} nested object
       * @return {object} flattened object
       */
      _flattenObject: function(obj) {
        var flattened = {};
        function recurse(current, property) {
          if (!property && Object.getOwnPropertyNames(current).length === 0) {
            return;
          }
          if (Object(current) !== current || Array.isArray(current)) {
            flattened[property] = current;
          } else {
            var isEmpty = true;
            for (var p in current) {
              isEmpty = false;
              recurse(current[p], property ? property + "." + p : p);
            }
            if (isEmpty) {
              flattened[property] = {};
            }
          }
        }
        if (obj) {
          recurse(obj);
        }
        return flattened;
      },
      /**
       * Extract value from nested object using string path with dot notation
       *
       * @param  {object} object to search in
       * @param  {string} path inside object
       * @return {any|void} value under the path
       */
      _objectPath: function(obj, path) {
        if (Object.prototype.hasOwnProperty.call(obj, path)) {
          return obj[path];
        }
        var keys = path.replace(/\[(\w+)\]/g, ".$1").replace(/^\./, "").split(".");
        var copy = {};
        for (var attr in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, attr)) {
            copy[attr] = obj[attr];
          }
        }
        for (var i = 0, l = keys.length; i < l; i++) {
          if (typeof copy === "object" && copy !== null && Object.hasOwnProperty.call(copy, keys[i])) {
            copy = copy[keys[i]];
          } else {
            return;
          }
        }
        return copy;
      },
      /**
       * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }
       *
       * @param  {object} rules
       * @return {object}
       */
      _parseRules: function(rules) {
        var parsedRules = {};
        rules = this._flattenObject(rules);
        for (var attribute in rules) {
          var rulesArray = rules[attribute];
          this._parseRulesCheck(attribute, rulesArray, parsedRules);
        }
        return parsedRules;
      },
      _parseRulesCheck: function(attribute, rulesArray, parsedRules, wildCardValues) {
        if (attribute.indexOf("*") > -1) {
          this._parsedRulesRecurse(attribute, rulesArray, parsedRules, wildCardValues);
        } else {
          this._parseRulesDefault(attribute, rulesArray, parsedRules, wildCardValues);
        }
      },
      _parsedRulesRecurse: function(attribute, rulesArray, parsedRules, wildCardValues) {
        var parentPath = attribute.substr(0, attribute.indexOf("*") - 1);
        var propertyValue = this._objectPath(this.input, parentPath);
        if (propertyValue) {
          for (var propertyNumber = 0; propertyNumber < propertyValue.length; propertyNumber++) {
            var workingValues = wildCardValues ? wildCardValues.slice() : [];
            workingValues.push(propertyNumber);
            this._parseRulesCheck(attribute.replace("*", propertyNumber), rulesArray, parsedRules, workingValues);
          }
        }
      },
      _parseRulesDefault: function(attribute, rulesArray, parsedRules, wildCardValues) {
        var attributeRules = [];
        if (rulesArray instanceof Array) {
          rulesArray = this._prepareRulesArray(rulesArray);
        }
        if (typeof rulesArray === "string") {
          rulesArray = rulesArray.split("|");
        }
        for (var i = 0, len = rulesArray.length, rule; i < len; i++) {
          rule = typeof rulesArray[i] === "string" ? this._extractRuleAndRuleValue(rulesArray[i]) : rulesArray[i];
          if (rule.value) {
            rule.value = this._replaceWildCards(rule.value, wildCardValues);
            this._replaceWildCardsMessages(wildCardValues);
          }
          if (Rules.isAsync(rule.name)) {
            this.hasAsync = true;
          }
          attributeRules.push(rule);
        }
        parsedRules[attribute] = attributeRules;
      },
      _replaceWildCards: function(path, nums) {
        if (!nums) {
          return path;
        }
        var path2 = path;
        nums.forEach(function(value) {
          if (Array.isArray(path2)) {
            path2 = path2[0];
          }
          const pos = path2.indexOf("*");
          if (pos === -1) {
            return path2;
          }
          path2 = path2.substr(0, pos) + value + path2.substr(pos + 1);
        });
        if (Array.isArray(path)) {
          path[0] = path2;
          path2 = path;
        }
        return path2;
      },
      _replaceWildCardsMessages: function(nums) {
        var customMessages = this.messages.customMessages;
        var self = this;
        Object.keys(customMessages).forEach(function(key) {
          if (nums) {
            var newKey = self._replaceWildCards(key, nums);
            customMessages[newKey] = customMessages[key];
          }
        });
        this.messages._setCustom(customMessages);
      },
      /**
       * Prepare rules if it comes in Array. Check for objects. Need for type validation.
       *
       * @param  {array} rulesArray
       * @return {array}
       */
      _prepareRulesArray: function(rulesArray) {
        var rules = [];
        for (var i = 0, len = rulesArray.length; i < len; i++) {
          if (typeof rulesArray[i] === "object") {
            for (var rule in rulesArray[i]) {
              rules.push({
                name: rule,
                value: rulesArray[i][rule]
              });
            }
          } else {
            rules.push(rulesArray[i]);
          }
        }
        return rules;
      },
      /**
       * Determines if the attribute is supplied with the original data object.
       *
       * @param  {array} attribute
       * @return {boolean}
       */
      _suppliedWithData: function(attribute) {
        return this.input.hasOwnProperty(attribute);
      },
      /**
       * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3
       *
       * @param  {string} ruleString min:3
       * @return {object} object containing the name of the rule and value
       */
      _extractRuleAndRuleValue: function(ruleString) {
        var rule = {}, ruleArray;
        rule.name = ruleString;
        if (ruleString.indexOf(":") >= 0) {
          ruleArray = ruleString.split(":");
          rule.name = ruleArray[0];
          rule.value = ruleArray.slice(1).join(":");
        }
        return rule;
      },
      /**
       * Determine if attribute has any of the given rules
       *
       * @param  {string}  attribute
       * @param  {array}   findRules
       * @return {boolean}
       */
      _hasRule: function(attribute, findRules) {
        var rules = this.rules[attribute] || [];
        for (var i = 0, len = rules.length; i < len; i++) {
          if (findRules.indexOf(rules[i].name) > -1) {
            return true;
          }
        }
        return false;
      },
      /**
       * Determine if attribute has any numeric-based rules.
       *
       * @param  {string}  attribute
       * @return {Boolean}
       */
      _hasNumericRule: function(attribute) {
        return this._hasRule(attribute, this.numericRules);
      },
      /**
       * Determine if rule is validatable
       *
       * @param  {Rule}   rule
       * @param  {mixed}  value
       * @return {boolean}
       */
      _isValidatable: function(rule, value) {
        if (Array.isArray(value)) {
          return true;
        }
        if (Rules.isImplicit(rule.name)) {
          return true;
        }
        return this.getRule("required").validate(value);
      },
      /**
       * Determine if we should stop validating.
       *
       * @param  {string} attribute
       * @param  {boolean} rulePassed
       * @return {boolean}
       */
      _shouldStopValidating: function(attribute, rulePassed) {
        var stopOnAttributes = this.stopOnAttributes;
        if (typeof stopOnAttributes === "undefined" || stopOnAttributes === false || rulePassed === true) {
          return false;
        }
        if (stopOnAttributes instanceof Array) {
          return stopOnAttributes.indexOf(attribute) > -1;
        }
        return true;
      },
      /**
       * Set custom attribute names.
       *
       * @param {object} attributes
       * @return {void}
       */
      setAttributeNames: function(attributes) {
        this.messages._setAttributeNames(attributes);
      },
      /**
       * Set the attribute formatter.
       *
       * @param {fuction} func
       * @return {void}
       */
      setAttributeFormatter: function(func) {
        this.messages._setAttributeFormatter(func);
      },
      /**
       * Get validation rule
       *
       * @param  {string} name
       * @return {Rule}
       */
      getRule: function(name) {
        return Rules.make(name, this);
      },
      /**
       * Stop on first error.
       *
       * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.
       * @return {void}
       */
      stopOnError: function(attributes) {
        this.stopOnAttributes = attributes;
      },
      /**
       * Determine if validation passes
       *
       * @param {function} passes
       * @return {boolean|undefined}
       */
      passes: function(passes) {
        var async = this._checkAsync("passes", passes);
        if (async) {
          return this.checkAsync(passes);
        }
        return this.check();
      },
      /**
       * Determine if validation fails
       *
       * @param {function} fails
       * @return {boolean|undefined}
       */
      fails: function(fails) {
        var async = this._checkAsync("fails", fails);
        if (async) {
          return this.checkAsync(function() {
          }, fails);
        }
        return !this.check();
      },
      /**
       * Check if validation should be called asynchronously
       *
       * @param  {string}   funcName Name of the caller
       * @param  {function} callback
       * @return {boolean}
       */
      _checkAsync: function(funcName, callback) {
        var hasCallback = typeof callback === "function";
        if (this.hasAsync && !hasCallback) {
          throw funcName + " expects a callback when async rules are being tested.";
        }
        return this.hasAsync || hasCallback;
      }
    };
    Validator.setMessages = function(lang, messages) {
      Lang._set(lang, messages);
      return this;
    };
    Validator.getMessages = function(lang) {
      return Lang._get(lang);
    };
    Validator.useLang = function(lang) {
      this.prototype.lang = lang;
    };
    Validator.getDefaultLang = function() {
      return this.prototype.lang;
    };
    Validator.setAttributeFormatter = function(func) {
      this.prototype.attributeFormatter = func;
    };
    Validator.stopOnError = function(attributes) {
      this.prototype.stopOnAttributes = attributes;
    };
    Validator.register = function(name, fn, message, fnReplacement) {
      var lang = Validator.getDefaultLang();
      Rules.register(name, fn);
      Lang._setRuleMessage(lang, name, message);
    };
    Validator.registerImplicit = function(name, fn, message, fnReplacement) {
      var lang = Validator.getDefaultLang();
      Rules.registerImplicit(name, fn);
      Lang._setRuleMessage(lang, name, message);
    };
    Validator.registerAsync = function(name, fn, message, fnReplacement) {
      var lang = Validator.getDefaultLang();
      Rules.registerAsync(name, fn);
      Lang._setRuleMessage(lang, name, message);
    };
    Validator.registerAsyncImplicit = function(name, fn, message) {
      var lang = Validator.getDefaultLang();
      Rules.registerAsyncImplicit(name, fn);
      Lang._setRuleMessage(lang, name, message);
    };
    Validator.registerMissedRuleValidator = function(fn, message) {
      Rules.registerMissedRuleValidator(fn, message);
    };
    module.exports = Validator;
  }
});

// node_modules/react-form-input-validation/dist/bundle.js
var require_bundle = __commonJS({
  "node_modules/react-form-input-validation/dist/bundle.js"(exports, module) {
    !function(t, e) {
      if ("object" == typeof exports && "object" == typeof module) module.exports = e(require_react(), require_validator());
      else if ("function" == typeof define && define.amd) define(["react", "validatorjs"], e);
      else {
        var n = "object" == typeof exports ? e(require_react(), require_validator()) : e(t.react, t.validatorjs);
        for (var r in n) ("object" == typeof exports ? exports : t)[r] = n[r];
      }
    }(window, function(t, e) {
      return function(t2) {
        var e2 = {};
        function n(r) {
          if (e2[r]) return e2[r].exports;
          var o = e2[r] = { i: r, l: false, exports: {} };
          return t2[r].call(o.exports, o, o.exports, n), o.l = true, o.exports;
        }
        return n.m = t2, n.c = e2, n.d = function(t3, e3, r) {
          n.o(t3, e3) || Object.defineProperty(t3, e3, { enumerable: true, get: r });
        }, n.r = function(t3) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
        }, n.t = function(t3, e3) {
          if (1 & e3 && (t3 = n(t3)), 8 & e3) return t3;
          if (4 & e3 && "object" == typeof t3 && t3 && t3.__esModule) return t3;
          var r = /* @__PURE__ */ Object.create(null);
          if (n.r(r), Object.defineProperty(r, "default", { enumerable: true, value: t3 }), 2 & e3 && "string" != typeof t3) for (var o in t3) n.d(r, o, (function(e4) {
            return t3[e4];
          }).bind(null, o));
          return r;
        }, n.n = function(t3) {
          var e3 = t3 && t3.__esModule ? function() {
            return t3.default;
          } : function() {
            return t3;
          };
          return n.d(e3, "a", e3), e3;
        }, n.o = function(t3, e3) {
          return Object.prototype.hasOwnProperty.call(t3, e3);
        }, n.p = "", n(n.s = 2);
      }([function(e2, n) {
        e2.exports = t;
      }, function(t2, n) {
        t2.exports = e;
      }, function(t2, e2, n) {
        "use strict";
        n.r(e2), n.d(e2, "Lang", function() {
          return r;
        }), n.d(e2, "useFormInputValidation", function() {
          return v;
        });
        var r, o = n(1), i = /* @__PURE__ */ function() {
          var t3 = function(e3, n2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
              t4.__proto__ = e4;
            } || function(t4, e4) {
              for (var n3 in e4) Object.prototype.hasOwnProperty.call(e4, n3) && (t4[n3] = e4[n3]);
            })(e3, n2);
          };
          return function(e3, n2) {
            if ("function" != typeof n2 && null !== n2) throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
            function r2() {
              this.constructor = e3;
            }
            t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
          };
        }();
        !function(t3) {
          t3.ar = "ar", t3.az = "az", t3.be = "be", t3.bg = "bg", t3.bs = "bs", t3.ca = "ca", t3.cs = "cs", t3.cy = "cy", t3.da = "da", t3.de = "de", t3.el = "el", t3.en = "en", t3.es = "es", t3.et = "et", t3.eu = "eu", t3.fa = "fa", t3.fi = "fi", t3.fr = "fr", t3.hr = "hr", t3.hu = "hu", t3.id = "id", t3.it = "it", t3.ja = "ja", t3.ka = "ka", t3.ko = "ko", t3.It = "It", t3.Iv = "Iv", t3.mk = "mk", t3.mn = "mn", t3.ms = "ms", t3.nb_NO = "nb_NO", t3.nl = "nl", t3.pl = "pl", t3.pt = "pt", t3.pt_BR = "pt_BR", t3.ro = "ro", t3.ru = "ru", t3.se = "se", t3.sl = "sl", t3.sq = "sq", t3.sr = "sr", t3.sv = "sv", t3.tr = "tr", t3.ua = "ua", t3.uk = "uk", t3.vi = "vi", t3.zh = "zh", t3.zh_TW = "zh_TW";
        }(r || (r = {}));
        var a, u = function(t3) {
          function e3(e4, n2) {
            return t3.call(this) || this;
          }
          return i(e3, t3), e3.useLang = function(t4) {
          }, e3.register = function(t4, e4, n2) {
          }, e3.registerAsync = function(t4, e4, n2) {
          }, e3.setMessages = function(t4, e4) {
          }, e3.getMessages = function(t4) {
            return a;
          }, e3.getDefaultLang = function() {
            return a;
          }, e3.setAttributeFormatter = function(t4) {
          }, e3.prototype.addEventListener = function(t4, e4) {
            return a;
          }, e3.prototype.removeEventListener = function(t4, e4) {
            return a;
          }, e3.prototype.useRules = function(t4) {
          }, e3.prototype.handleChangeEvent = function(t4) {
          }, e3.prototype.handleBlurEvent = function(t4) {
          }, e3.prototype.handleSubmit = function(t4) {
          }, e3;
        }(function() {
          function t3() {
            this.listeners = {};
          }
          return t3.prototype.addListener = function(t4, e3) {
            t4 in this.listeners || (this.listeners[t4] = []), this.listeners[t4].push(e3);
          }, t3.prototype.removeListener = function(t4, e3) {
            if (t4 in this.listeners) {
              for (var n2 = this.listeners[t4], r2 = 0, o2 = n2.length; r2 < o2; r2++) if (n2[r2] === e3) return void n2.splice(r2, 1);
            }
          }, t3.prototype.emit = function(t4) {
            if (!(t4.type in this.listeners)) return true;
            for (var e3 = this.listeners[t4.type].slice(), n2 = 0, r2 = e3.length; n2 < r2; n2++) e3[n2].call(this, t4.detail);
            return !t4.defaultPrevented;
          }, t3;
        }()), c = n(0), s = function(t3, e3, n2) {
          if (n2 || 2 === arguments.length) for (var r2, o2 = 0, i2 = e3.length; o2 < i2; o2++) !r2 && o2 in e3 || (r2 || (r2 = Array.prototype.slice.call(e3, 0, o2)), r2[o2] = e3[o2]);
          return t3.concat(r2 || Array.prototype.slice.call(e3));
        }, f = function(t3) {
          var e3 = document.getElementsByName(t3.name), n2 = [];
          return s([], e3, true).filter(function(t4) {
            return true === t4.checked;
          }).forEach(function(t4) {
            return n2.push(t4.value);
          }), n2;
        }, l = function(t3) {
          var e3 = document.getElementsByName(t3.name), n2 = s([], e3, true).filter(function(t4) {
            return true === t4.checked;
          });
          return n2[0] ? n2[0].value : "";
        }, p = function(t3, e3) {
          Object.keys(t3).forEach(function(t4) {
            delete e3[t4];
          });
        }, h = function(t3) {
          var e3 = {};
          return Object.keys(t3.errors.all()).forEach(function(n2) {
            e3[n2] = t3.errors.first(n2);
          }), e3;
        }, b = function() {
          return (b = Object.assign || function(t3) {
            for (var e3, n2 = 1, r2 = arguments.length; n2 < r2; n2++) for (var o2 in e3 = arguments[n2]) Object.prototype.hasOwnProperty.call(e3, o2) && (t3[o2] = e3[o2]);
            return t3;
          }).apply(this, arguments);
        }, d = function(t3, e3, n2, r2) {
          return new (n2 || (n2 = Promise))(function(o2, i2) {
            function a2(t4) {
              try {
                c2(r2.next(t4));
              } catch (t5) {
                i2(t5);
              }
            }
            function u2(t4) {
              try {
                c2(r2.throw(t4));
              } catch (t5) {
                i2(t5);
              }
            }
            function c2(t4) {
              t4.done ? o2(t4.value) : function(t5) {
                return t5 instanceof n2 ? t5 : new n2(function(e4) {
                  e4(t5);
                });
              }(t4.value).then(a2, u2);
            }
            c2((r2 = r2.apply(t3, e3 || [])).next());
          });
        }, y = function(t3, e3) {
          var n2, r2, o2, i2, a2 = { label: 0, sent: function() {
            if (1 & o2[0]) throw o2[1];
            return o2[1];
          }, trys: [], ops: [] };
          return i2 = { next: u2(0), throw: u2(1), return: u2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
            return this;
          }), i2;
          function u2(i3) {
            return function(u3) {
              return function(i4) {
                if (n2) throw new TypeError("Generator is already executing.");
                for (; a2; ) try {
                  if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done) return o2;
                  switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
                    case 0:
                    case 1:
                      o2 = i4;
                      break;
                    case 4:
                      return a2.label++, { value: i4[1], done: false };
                    case 5:
                      a2.label++, r2 = i4[1], i4 = [0];
                      continue;
                    case 7:
                      i4 = a2.ops.pop(), a2.trys.pop();
                      continue;
                    default:
                      if (!(o2 = (o2 = a2.trys).length > 0 && o2[o2.length - 1]) && (6 === i4[0] || 2 === i4[0])) {
                        a2 = 0;
                        continue;
                      }
                      if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                        a2.label = i4[1];
                        break;
                      }
                      if (6 === i4[0] && a2.label < o2[1]) {
                        a2.label = o2[1], o2 = i4;
                        break;
                      }
                      if (o2 && a2.label < o2[2]) {
                        a2.label = o2[2], a2.ops.push(i4);
                        break;
                      }
                      o2[2] && a2.ops.pop(), a2.trys.pop();
                      continue;
                  }
                  i4 = e3.call(t3, a2);
                } catch (t4) {
                  i4 = [6, t4], r2 = 0;
                } finally {
                  n2 = o2 = 0;
                }
                if (5 & i4[0]) throw i4[1];
                return { value: i4[0] ? i4[1] : void 0, done: true };
              }([i3, u3]);
            };
          }
        };
        function v(t3, e3) {
          var n2 = this;
          void 0 === t3 && (t3 = {});
          var r2 = Object(c.useRef)(t3), i2 = Object(c.useRef)({}), a2 = Object(c.useState)(e3 || {}), u2 = a2[0], s2 = a2[1], v2 = Object(c.useState)(r2.current), m2 = v2[0], g2 = v2[1], j = Object(c.useState)(i2.current), O = j[0], k = j[1], _ = Object(c.useState)(false), E = _[0], w = _[1], A = Object(c.useCallback)(function(t4) {
            s2(t4);
          }, []), x = Object(c.useCallback)(function(t4) {
            o.useLang(t4);
          }, []), S = Object(c.useCallback)(function(t4, e4, n3) {
            o.register(t4, e4, n3);
          }, []), L = Object(c.useCallback)(function(t4, e4, n3) {
            o.registerAsync(t4, e4, n3);
          }, []), C = Object(c.useCallback)(function(t4, e4) {
            o.setMessages(t4, e4);
          }, []), P = Object(c.useCallback)(function(t4) {
            return o.getMessages(t4);
          }, []), M = Object(c.useCallback)(function() {
            return o.getDefaultLang();
          }, []), q = Object(c.useCallback)(function(t4) {
            o.setAttributeFormatter(t4);
          }, []), B = Object(c.useCallback)(function(t4) {
            var e4 = t4.target.name;
            if (e4) {
              var n3 = "checkbox" === t4.target.type ? f(t4.target) : "radio" === t4.target.type ? l(t4.target) : t4.target.value;
              r2.current[e4] = n3, g2(function(t5) {
                var r3;
                return b(b({}, t5), ((r3 = {})[e4] = n3, r3));
              });
            }
          }, []), F = function(t4) {
            return new Promise(function(e4) {
              var n3 = {}, r3 = {}, a3 = {}, c2 = false;
              t4.forEach(function(t5) {
                var e5 = t5.getAttribute("name");
                if (n3[e5] = m2[e5], r3[e5] = u2[e5], r3[e5] || (console.warn("Rule is not defind for ".concat(e5)), r3[e5] = ""), e5.endsWith("_confirmation")) {
                  var o2 = e5.slice(0, e5.indexOf("_confirmation"));
                  n3[o2] = m2[o2];
                }
                t5.hasAttribute("data-attribute-name") && (a3[e5] = t5.getAttribute("data-attribute-name")), t5.hasAttribute("data-async") && (c2 = true);
              });
              var s3 = new o(n3, r3);
              if (s3.setAttributeNames(a3), !c2) {
                if (s3.fails()) {
                  var f2 = h(s3);
                  return e4(b(b({}, O), f2));
                }
                return p(n3, i2.current), e4(i2.current);
              }
              s3.checkAsync(function() {
                p(n3, i2.current), e4(i2.current);
              }, function() {
                var t5 = h(s3);
                e4(b(b({}, O), t5));
              });
            });
          }, R = Object(c.useCallback)(function(t4) {
            var e4 = t4.target;
            F([e4]).then(function(t5) {
              Object.entries(t5).forEach(function(t6) {
                var e5 = t6[0], n3 = t6[1];
                i2.current[e5] = n3;
              }), k(function(e5) {
                return b(b({}, e5), t5);
              });
            }).catch(function(t5) {
              return console.error(t5);
            });
          }, []), D = Object(c.useCallback)(function(t4) {
            return d(n2, void 0, void 0, function() {
              return y(this, function(e4) {
                return t4.preventDefault(), [2, new Promise(function(e5) {
                  (function(t5) {
                    var e6 = [];
                    return t5.querySelectorAll("textarea,select,input:not([type='submit']):not([type='file']):not([data-ignore-validation])").forEach(function(t6) {
                      e6.push(t6);
                    }), new Promise(function(t6) {
                      F(e6).then(function(e7) {
                        Object.entries(e7).forEach(function(t7) {
                          var e8 = t7[0], n3 = t7[1];
                          i2.current[e8] = n3;
                        }), k(function(t7) {
                          return b(b({}, t7), e7);
                        }), t6(0 === Object.keys(e7).length);
                      }).catch(function(t7) {
                        return console.log(t7);
                      });
                    });
                  })(t4.target).then(function(t5) {
                    t5 && w(true), e5(t5);
                  });
                })];
              });
            });
          }, []);
          return [Object(c.useMemo)(function() {
            return m2;
          }, []), Object(c.useMemo)(function() {
            return O;
          }, []), Object(c.useMemo)(function() {
            return { isValidForm: E, useRules: A, useLang: x, register: S, registerAsync: L, setMessages: C, setAttributeFormatter: q, getMessages: P, getDefaultLang: M, handleChangeEvent: B, handleBlurEvent: R, handleSubmit: D, validate: D };
          }, [E])];
        }
        var m = /* @__PURE__ */ function() {
          var t3 = function(e3, n2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
              t4.__proto__ = e4;
            } || function(t4, e4) {
              for (var n3 in e4) Object.prototype.hasOwnProperty.call(e4, n3) && (t4[n3] = e4[n3]);
            })(e3, n2);
          };
          return function(e3, n2) {
            if ("function" != typeof n2 && null !== n2) throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
            function r2() {
              this.constructor = e3;
            }
            t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
          };
        }(), g = function(t3) {
          function e3(n2, r2) {
            var o2 = t3.call(this, n2, r2) || this;
            return o2.rules = {}, o2.errors = {}, e3.useLang(r2 && r2.locale ? r2.locale : "en"), o2.component = n2, o2.handleChangeEvent = o2.handleChangeEvent.bind(o2), o2.handleSubmit = o2.handleSubmit.bind(o2), o2.handleBlurEvent = o2.handleBlurEvent.bind(o2), o2;
          }
          return m(e3, t3), e3.useLang = function(t4) {
            o.useLang(t4);
          }, e3.register = function(t4, e4, n2) {
            o.register(t4, e4, n2);
          }, e3.registerAsync = function(t4, e4, n2) {
            o.registerAsync(t4, e4, n2);
          }, e3.setMessages = function(t4, e4) {
            o.setMessages(t4, e4);
          }, e3.getMessages = function(t4) {
            return o.getMessages(t4);
          }, e3.getDefaultLang = function() {
            return o.getDefaultLang();
          }, e3.setAttributeFormatter = function(t4) {
            o.setAttributeFormatter(t4);
          }, Object.defineProperty(e3.prototype, "onformsubmit", { get: function() {
            return this._onformsubmit;
          }, set: function(e4) {
            this._onformsubmit && t3.prototype.removeListener.call(this, "formsubmit", this._onformsubmit), this._onformsubmit = e4, t3.prototype.addListener.call(this, "formsubmit", this._onformsubmit);
          }, enumerable: false, configurable: true }), e3.prototype.addEventListener = function(e4, n2) {
            return t3.prototype.addListener.call(this, e4, n2), this;
          }, e3.prototype.removeEventListener = function(e4, n2) {
            return t3.prototype.removeListener.call(this, e4, n2), this;
          }, e3.prototype.useRules = function(t4) {
            this.rules = t4;
          }, e3.prototype.handleChangeEvent = function(t4) {
            var e4 = t4.target.name;
            if (this.component && e4) {
              var n2 = Object.assign({}, this.component.state.fields);
              n2[e4] = "checkbox" === t4.target.type ? f(t4.target) : "radio" === t4.target.type ? l(t4.target) : t4.target.value, this.component.setState({ fields: n2, isValidatorUpdate: true });
            }
          }, e3.prototype.handleBlurEvent = function(t4) {
            var e4 = this, n2 = t4.target;
            this.validate([n2]).then(function(t5) {
              e4.component && e4.component.hasOwnProperty("state") && (e4.errors = Object.assign(e4.errors, t5), e4.component.setState({ errors: e4.errors, isValidatorUpdate: true }));
            }).catch(function(t5) {
              return console.error(t5);
            });
          }, e3.prototype.handleSubmit = function(e4) {
            var n2 = this;
            e4.preventDefault(), this.validateForm(e4.target).then(function(e5) {
              e5 && t3.prototype.emit.call(n2, n2.getEvent(n2.component.state.fields));
            });
          }, e3.prototype.validateForm = function(t4) {
            var e4 = this;
            this.component && this.component.state || (this.component.state = { errors: {} });
            var n2 = [];
            return t4.querySelectorAll("textarea,select,input:not([type='submit']):not([type='file']):not([data-ignore-validation])").forEach(function(t5) {
              n2.push(t5);
            }), new Promise(function(r2) {
              e4.validate(n2).then(function(n3) {
                e4.errors = n3, e4.component.setState({ errors: e4.errors, isValidatorUpdate: true }), Object.keys(e4.component.state.errors)[0] && t4.querySelector('[name="'.concat(Object.keys(e4.component.state.errors)[0], '"]')) && t4.querySelector('[name="'.concat(Object.keys(e4.component.state.errors)[0], '"]')).focus(), r2(0 === Object.keys(e4.component.state.errors).length);
              }).catch(function(t5) {
                return console.log(t5);
              });
            });
          }, e3.prototype.validate = function(t4) {
            var e4 = this;
            return new Promise(function(n2) {
              var r2 = {}, i2 = {}, a2 = {}, u2 = {}, c2 = false;
              t4.forEach(function(t5) {
                var n3 = t5.getAttribute("name");
                if (i2[n3] = e4.component.state.fields[n3], a2[n3] = e4.rules[n3], a2[n3] || (console.warn("Rule is not defind for ".concat(n3)), a2[n3] = ""), n3.endsWith("_confirmation")) {
                  var r3 = n3.slice(0, n3.indexOf("_confirmation"));
                  i2[r3] = e4.component.state.fields[r3];
                }
                t5.hasAttribute("data-attribute-name") && (u2[n3] = t5.getAttribute("data-attribute-name")), t5.hasAttribute("data-async") && (c2 = true);
              });
              var s2 = new o(i2, a2);
              if (s2.setAttributeNames(u2), !c2) return s2.fails() ? (r2 = h(s2), n2(r2)) : (e4.invalidateErrors(i2), n2(r2));
              s2.checkAsync(function() {
                e4.invalidateErrors(i2), n2(r2);
              }, function() {
                r2 = h(s2), n2(r2);
              });
            });
          }, e3.prototype.invalidateErrors = function(t4) {
            var e4 = this;
            Object.keys(t4).forEach(function(t5) {
              delete e4.errors[t5];
            });
          }, e3.prototype.getEvent = function(t4) {
            return new CustomEvent("formsubmit", { detail: t4 });
          }, e3;
        }(u);
        e2.default = g;
      }]);
    });
  }
});
export default require_bundle();
//# sourceMappingURL=react-form-input-validation.js.map
